# data-structure_week10-不相交集
解决等价问题、简单、快速、需要常数平均时间、分析困难
## 8.1等价关系
- 关系R，S，等价类的总结
有R关系不代表一定是等价关系
对于a∈S，定义关系R，不代表S中的元素都和a有R关系，S中存放的是 准备看是否和a有关系R的元素。
- 等价关系R性质：
1.自反性 aRa
2.对称性 aRb当且仅当 bRa
3.传递性 若aRb且bRc，则aRc
- 常见的等价关系：
电气连接、两城市位于同一个国家、通过双向公路从城镇a到b，ab是等价关系
## 动态等价关系
 ## 8.3基本数据结构
使用一个树来表示一个集合，用根结点来命名该合集（每个树的根节点是相同的）
树不必一定是二叉树，但二叉树表示最方便
树的集合叫森林，用数组来表示该森林
数组的每个成员P[i]来表示元素i的父亲
- 算法实现：数组记录父指针
* 初始状态：是每个树里只有根节点，父指针为0
* 之后的子节点唯一的信息就是父指针
* union（X,Y）的运算：一个结点的根指针指向另一棵树的根结点，采纳执行union（X,Y）后的新根节点是X
* find（X）的操作通过返回包含X的树的根完成
## 8.4灵巧求并算法——针对Union
### 按大小求并
让较小树成为较大树的子树
ps：按照任意的顺序进行并集 means：只单纯在Union（X，Y）中把X当作Y的根节点，这样子将会生成更深的树。可证明  按大小求并形成的树深度不超过 log N。
- 算法实现：数组来记录每个树的大小的负值，
* 初始状态：初始时数组元素大小为-1.
* 当求并时，节点的深度随着Union的结果而增加，他被置于至少是他以前所在树的两倍大的树上的理
* 执行Union时要检查树的大小，新的大小是老的大小的和（-1之间相加）
* 其他节点在数组上保存其父节点，为正值（也就是说在数组上在，正值表示父节点，负值就表示树的大小）
### 按高度求并
  跟踪的是每个树的高度而不是大小，执行Union让较浅的树成为深的树的子树
- 算法实现：用数组记录每棵树的高度的负值
* 初始状态：初始数组元素为0
* 求并时:
* 如果:S[Root1] == S[Root2]，Root1的高度增加1（也就是-1），Root2结点保存对方的数组元素下标作为父节点（为正值，也就是Root1）
* 如果：Root2更深更高，让Root2作为Root1的父节点，保存在Root1的节点中
## 8.5路径压缩——针对Find
从X到根的路径上的每一个结点都使他的父节点变成根节点
- 算法实现：
* 使S[X]等于由Find返回的值，使用递归算法，到最后X直接指根节点
* ps：路径压缩不完全与按高度求并兼容，路径压缩会改变树的高度
## 8.6按秩求并和路径压缩的最坏情况
